{"version":3,"file":"react-async-component.min.js","sources":["../src/createAsyncContext.js","../src/AsyncComponentProvider.js","../src/asyncComponent.js"],"sourcesContent":["export default () => {\n  let idPointer = 0\n  const registry = {}\n  const errors = {}\n  return {\n    getNextId: () => {\n      idPointer += 1\n      return idPointer\n    },\n    resolved(id) {\n      registry[id] = true\n    },\n    failed(id, error) {\n      errors[id] = error\n    },\n    getState() {\n      return {\n        resolved: Object.keys(registry).reduce(\n          (acc, cur) => Object.assign(acc, { [cur]: true }),\n          {},\n        ),\n        errors,\n      }\n    },\n  }\n}\n","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nimport createAsyncContext from './createAsyncContext'\n\nexport default class AsyncComponentProvider extends Component {\n  static propTypes = {\n    children: PropTypes.node.isRequired,\n    asyncContext: PropTypes.shape({\n      getNextId: PropTypes.func.isRequired,\n      resolved: PropTypes.func.isRequired,\n      failed: PropTypes.func.isRequired,\n      getState: PropTypes.func.isRequired,\n    }),\n    rehydrateState: PropTypes.shape({\n      resolved: PropTypes.object,\n    }),\n  }\n\n  static defaultProps = {\n    asyncContext: undefined,\n    rehydrateState: {\n      resolved: {},\n    },\n  }\n\n  static childContextTypes = {\n    asyncComponents: PropTypes.shape({\n      getNextId: PropTypes.func.isRequired,\n      resolved: PropTypes.func.isRequired,\n      failed: PropTypes.func.isRequired,\n      shouldRehydrate: PropTypes.func.isRequired,\n      getError: PropTypes.func.isRequired,\n    }).isRequired,\n  }\n\n  componentWillMount() {\n    this.asyncContext = this.props.asyncContext || createAsyncContext()\n    this.rehydrateState = this.props.rehydrateState\n  }\n\n  getChildContext() {\n    return {\n      asyncComponents: {\n        getNextId: this.asyncContext.getNextId,\n        resolved: this.asyncContext.resolved,\n        failed: this.asyncContext.failed,\n        shouldRehydrate: id => {\n          const resolved = this.rehydrateState.resolved[id]\n          delete this.rehydrateState.resolved[id]\n          return resolved\n        },\n        getError: id =>\n          this.rehydrateState.errors && this.rehydrateState.errors[id],\n      },\n    }\n  }\n\n  render() {\n    return React.Children.only(this.props.children)\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\n\nconst validSSRModes = ['resolve', 'defer', 'boundary']\n\nexport default function asyncComponent(config) {\n  const {\n    name,\n    resolve,\n    autoResolveES2015Default = true,\n    serverMode = 'resolve',\n    LoadingComponent,\n    ErrorComponent,\n  } = config\n\n  if (validSSRModes.indexOf(serverMode) === -1) {\n    throw new Error('Invalid serverMode provided to asyncComponent')\n  }\n\n  const env =\n    ['node', 'browser'].indexOf(config.env) > -1\n      ? config.env\n      : typeof window === 'undefined' ? 'node' : 'browser'\n\n  const state = {\n    // A unique id we will assign to our async component which is especially\n    // useful when rehydrating server side rendered async components.\n    id: null,\n    // This will be use to hold the resolved module allowing sharing across\n    // instances.\n    // NOTE: When using React Hot Loader this reference will become null.\n    module: null,\n    // If an error occurred during a resolution it will be stored here.\n    error: null,\n    // Allows us to share the resolver promise across instances.\n    resolver: null,\n    // Indicates whether resolving is taking place\n    resolving: false,\n    // Handle on the contexts so we don't lose it during async resolution\n    asyncComponents: null,\n    asyncComponentsAncestor: null,\n  }\n\n  const needToResolveOnBrowser = () =>\n    state.module == null &&\n    state.error == null &&\n    !state.resolving &&\n    typeof window !== 'undefined'\n\n  // Takes the given module and if it has a \".default\" the \".default\" will\n  // be returned. i.e. handy when you could be dealing with es6 imports.\n  const es6Resolve = x =>\n    autoResolveES2015Default &&\n    x != null &&\n    (typeof x === 'function' || typeof x === 'object') &&\n    x.default\n      ? x.default\n      : x\n\n  const getResolver = () => {\n    if (state.resolver == null) {\n      state.resolving = true\n      try {\n        state.resolver = Promise.resolve(resolve())\n      } catch (err) {\n        state.resolver = Promise.reject(err)\n      }\n    }\n    return state.resolver\n  }\n\n  return class AsyncComponent extends React.Component {\n    static displayName = name || 'AsyncComponent'\n\n    static contextTypes = {\n      asyncComponentsAncestor: PropTypes.shape({\n        isBoundary: PropTypes.bool,\n      }),\n      asyncComponents: PropTypes.shape({\n        getNextId: PropTypes.func.isRequired,\n        resolved: PropTypes.func.isRequired,\n        shouldRehydrate: PropTypes.func.isRequired,\n      }),\n    }\n\n    static childContextTypes = {\n      asyncComponentsAncestor: PropTypes.shape({\n        isBoundary: PropTypes.bool,\n      }),\n    }\n\n    getChildContext() {\n      return {\n        asyncComponentsAncestor:\n          state.asyncComponents == null\n            ? null\n            : {\n                isBoundary: serverMode === 'boundary',\n              },\n      }\n    }\n\n    componentWillMount() {\n      if (this.context.asyncComponents != null) {\n        state.asyncComponents = this.context.asyncComponents\n        state.asyncComponentsAncestor = this.context.asyncComponentsAncestor\n        if (!state.id) {\n          state.id = this.context.asyncComponents.getNextId()\n        }\n      }\n    }\n\n    // react-async-bootstrapper\n    bootstrap() {\n      const doResolve = () =>\n        this.resolveModule().then(\n          module => (module === undefined ? false : undefined),\n        )\n\n      // browser\n      if (env === 'browser') {\n        const { shouldRehydrate, getError } = state.asyncComponents\n        const error = getError(state.id)\n        if (error) {\n          state.error = error\n          return false\n        }\n        return shouldRehydrate(state.id) ? doResolve() : false\n      }\n\n      // node\n      const isChildOfBoundary =\n        state.asyncComponentsAncestor != null &&\n        state.asyncComponentsAncestor.isBoundary\n\n      return serverMode === 'defer' || isChildOfBoundary ? false : doResolve()\n    }\n\n    componentDidMount() {\n      if (needToResolveOnBrowser()) {\n        this.resolveModule()\n      }\n    }\n\n    resolveModule() {\n      return getResolver()\n        .then(module => {\n          if (state.asyncComponents != null) {\n            state.asyncComponents.resolved(state.id)\n          }\n          state.module = module\n          state.error = null\n          state.resolving = false\n          return module\n        })\n        .catch(({ message, stack }) => {\n          const error = { message, stack }\n          if (state.asyncComponents != null) {\n            state.asyncComponents.failed(state.id, error)\n          }\n          state.error = error\n          state.resolving = false\n          if (!ErrorComponent) {\n            // eslint-disable-next-line no-console\n            console.error(error)\n          }\n        })\n        .then(result => {\n          if (this.unmounted) {\n            return undefined\n          }\n          if (\n            !this.context.reactAsyncBootstrapperRunning &&\n            env === 'browser'\n          ) {\n            this.forceUpdate()\n          }\n          return result\n        })\n    }\n\n    componentWillUnmount() {\n      this.unmounted = true\n    }\n\n    render() {\n      const { module, error } = state\n\n      if (error) {\n        return ErrorComponent ? (\n          <ErrorComponent {...this.props} error={error} />\n        ) : null\n      }\n\n      const Component = es6Resolve(module)\n      return Component ? (\n        <Component {...this.props} />\n      ) : LoadingComponent ? (\n        <LoadingComponent {...this.props} />\n      ) : null\n    }\n  }\n}\n"],"names":["idPointer","registry","errors","id","error","Object","keys","reduce","acc","cur","assign","AsyncComponentProvider","asyncContext","this","props","createAsyncContext","rehydrateState","getNextId","resolved","failed","_this2","React","Children","only","children","Component","propTypes","PropTypes","node","isRequired","shape","func","object","defaultProps","undefined","childContextTypes","validSSRModes","asyncComponent","config","name","resolve","autoResolveES2015Default","serverMode","LoadingComponent","ErrorComponent","indexOf","Error","env","window","state","asyncComponents","context","asyncComponentsAncestor","doResolve","resolveModule","then","module","shouldRehydrate","getError","isChildOfBoundary","isBoundary","resolving","resolver","Promise","err","reject","getResolver","catch","message","stack","_this3","unmounted","reactAsyncBootstrapperRunning","forceUpdate","result","x","default","displayName","contextTypes","bool"],"mappings":"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"}